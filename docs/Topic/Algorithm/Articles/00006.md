---
name: 算法中数组的应用
---

# 算法中数组的应用

下面要结合算法真题来对数组进行一些应用。

单纯针对数组来考察的题目，总体来说，都不算太难 —— 数组题目要想往难了出，基本都要结合排序、二分和动态规划这些相对复杂的算法思想才行。

## Map 的妙用 —— 两数求和问题

> 真题描述： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
>
> 示例: 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums [0] + nums [1] = 2 + 7 = 9 所以返回 [0, 1]

### 一个淳朴的解法

很快就能想出来一种淳朴的解法：直接使用双重循环。

但是这种算法很显然效率很低，O(n^2) 的时间复杂度很容易会让算法超时

那么需要寻找一种 o(1) 的时间复杂度的算法，即只循环一次

### 空间换时间，使用 Map

拿这道题来说，第二层循环其实根本没必要。

我们只需要记住一个结论：**几乎所有的求和问题，都可以转换为求差问题**。如果将求和转换为求差，那么这道题会非常简单。

给定一个和值，只需要在循环中，求出差值，并填入 map 中，那么每次循环只需要将自己与 map 中的差值作比对就好，如果有相等的，那么这两个数就是我们要的答案。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
const twoSum = function (nums, target) {
  // 这里我用对象来模拟 map 的能力
  const diffs = {}
  // 缓存数组长度
  const len = nums.length
  // 遍历数组
  for (let i = 0; i < len; i++) {
    // 判断当前值对应的 target 差值是否存在（是否已遍历过）
    if (diffs[target - nums[i]] !== undefined) {
      // 若有对应差值，那么答案get！
      return [diffs[target - nums[i]], i]
    }
    // 若没有对应差值，则记录当前值
    diffs[nums[i]] = i
  }
}
```

## 强大的双指针法

### 合并两个有序数组

> 真题描述：给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
>
> 说明：初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
>
> 示例: 输入:
>
> nums1 = [1,2,3,0,0,0], m = 3
>
> nums2 = [2,5,6], n = 3
>
> 输出: [1,2,2,3,5,6]

#### 标准解法

那么这道题没有太多的弯弯绕绕，直接使用双指针法就可以解决。

首先我们定义两个指针，分别指向两个数组的尾部：

- 每次只对指针所指的元素进行比较，取较大的元素，往 nums1 的尾部填充
- 由于这两个数组可能不一定长，所以还需要考虑提前到头的情况
- 如果提前遍历完的是 nums1，那么剩下的就是 nums2，此时 nums1 的头部就是空的，直接将 nums2 剩余部分填充进去即可
- 如果提前遍历完的是 nums2，那么由于 nums1 本身就是容器，不需要做额外的操作。

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
const merge = function (nums1, m, nums2, n) {
  // 初始化两个指针的指向，初始化 nums1 尾部索引k
  let i = m - 1; let j = n - 1; let k = m + n - 1
  // 当两个数组都没遍历完时，指针同步移动
  while (i >= 0 && j >= 0) {
    // 取较大的值，从末尾往前填补
    if (nums1[i] >= nums2[j]) {
      nums1[k] = nums1[i]
      i--
      k--
    }
    else {
      nums1[k] = nums2[j]
      j--
      k--
    }
  }

  // nums2 留下的情况，特殊处理一下
  while (j >= 0) {
    nums1[k] = nums2[j]
    k--
    j--
  }
}
```

### 三数求和的问题

双指针可以处理很多问题，例如三数求和问题：

虽然三数求和和两数求和之间名字看起来区别不大，但是解决办法却截然不同

> 真题描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。
>
> 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]
>
> 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

那么我们仍然可以采用**求差**的方式来解决，固定一个数，在剩下的数中寻找两个数，使得它们的和为 0，这样就可以得到三个数。

使用双指针，可以大大提高算法的效率(这里大家估计就明白双指针的使用场景了：一方面，它可以用空间换时间；另一方面，他可以帮助我们降低解决问题的复杂度）

> 双链用法在涉及到求和、比大小之类的范围中时，大前提就是：数组必须是有序的。否则双指针无法帮助我们来缩小定位的范围。

所以第一步就需要将数组排序

```js
nums.sort((a, b) => a - b)
```

那么我们就可以先固定一个数，再通过双指针来确定这三个数相加等于 0。

让左右指针分别指向头和尾，逐渐向中间靠拢

每次指针移动一次位置，就计算一下两个指针指向数字之和加上固定的那个数之后，是否等于 0。如果是，那么我们就得到了一个目标组合；否则，分两种情况来看：

- 相加之和大于 0，说明右侧的数偏大了，右指针左移
- 相加之和小于 0，说明左侧的数偏小了，左指针右移

> tips：这个数组在题目中要求了 “不重复的三元组”，因此我们还需要做一个重复元素的跳过处理。这一点在编码实现环节大家会注意到。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
const threeSum = function (nums) {
  // 用于存放结果数组
  const res = []
  // 给 nums 排序
  nums.sort((a, b) => a - b)
  // 缓存数组长度
  const len = nums.length
  // 注意我们遍历到倒数第三个数就足够了，因为左右指针会遍历后面两个数
  for (let i = 0; i < len - 2; i++) {
    // 左指针 j
    let j = i + 1
    // 右指针k
    let k = len - 1
    // 如果遇到重复的数字，则跳过
    if (i > 0 && nums[i] === nums[i - 1])
      continue
    while (j < k) {
      // 三数之和小于0，左指针前进
      if (nums[i] + nums[j] + nums[k] < 0) {
        j++
        // 处理左指针元素重复的情况
        while (j < k && nums[j] === nums[j - 1])
          j++

      }
      else if (nums[i] + nums[j] + nums[k] > 0) {
        // 三数之和大于0，右指针后退
        k--

        // 处理右指针元素重复的情况
        while (j < k && nums[k] === nums[k + 1])
          k--

      }
      else {
        // 得到目标数字组合，推入结果数组
        res.push([nums[i], nums[j], nums[k]])

        // 左右指针一起前进
        j++
        k--

        // 若左指针元素重复，跳过
        while (j < k && nums[j] === nums[j - 1])
          j++

        // 若右指针元素重复，跳过
        while (j < k && nums[k] === nums[k + 1])
          k--

      }
    }
  }
  // 返回结果数组
  return res
}
```

### 双指针中的“对撞指针法”

在上面这道题中，左右指针一起从两边往中间位置相互迫近，这样的特殊双指针形态，被称为 “对撞指针”。

什么时候你需要联想到对撞指针？
这里我给大家两个关键字 ——“有序” 和 “数组”。

没错，见到这两个关键字，立刻把双指针法调度进你的大脑内存。普通双指针走不通，立刻想对撞指针！

即便数组题目中并没有直接给出 “有序” 这个关键条件，我们在发觉普通思路走不下去的时候，也应该及时地尝试手动对其进行排序试试看有没有新的切入点 —— 没有条件，创造条件也要上。

对撞指针可以帮助我们缩小问题的范围，这一点在 “三数求和” 问题中体现得淋漓尽致

因为数组有序，所以我们可以用两个指针 “画地为牢” 圈出一个范围，这个范围以外的值不是太大就是太小、直接被排除在我们的判断逻辑之外，这样我们就可以把时间花在真正有意义的计算和对比上。如此一来，不仅节省了计算的时间，更降低了问题本身的复杂度，我们做题的速度也会大大加快。
